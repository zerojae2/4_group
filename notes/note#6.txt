가상함수
virtual 키워드로 선언된 멤버 함수이며 동적 바인딩 지시어이다. 컴파일러에게 함수에 대한 호출 바인딩을 실행시간까지 미루도록 지시를 하는 역할을 한다.

함수 오버라이딩
파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수를 선언한다. 
오버라이딩이란 베이스 클래스는 인터페이스 역할만하도록 유도하는것이고 실제 동작은 파생클래스에서만 작동되도록 하는것이다. 
결론적으로 사용하는 이유는 베이스 클래스를 상속받은 파생클래스를 호출하기 위해 사용한다.(다형성의 한 종류)

예제 9-2 
베이스에 virtual함수를 사용하면 Derived::f() called가 두번 나오게 되지만 
virtual 함수를 사용하지 않으면 Base::f() called와 Derived::f() called가 나오게 된다. 즉, virtual를 사용하면 베이스 클래스의 f()가 런타임시에 동적 바인딩을 해서 파생클래스의 f()가 나오게 된다. 

동적 바인딩 
파생 클래스에 대해 기본 클래스에 대한 포인터로 가상함수를 호출하는 경우 객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행하는것이다. 실행중에 이루어진다. 

C++ 오버라이딩 특징 
오버라이딩 시 virtual 지시어를 생략 할수 있다. 가상함수의 virtual 지시어는 상속되고, 파생 클래스에서 virtual 생략 가능하다. 가상 함수의 접근을 private, protected, public 중 자유롭게 지정 가능하다. 

예제 9-3 
상속에서 배웠던거와 동일하게 GrandDerived는 Derived를 Derived는 Base를 상속하기 때문에 동적 바인딩에 의해 모두 GrandDerived의 함수 f()를 호출하게 된다. 

가상소멸자 
사용하기 위해선 소멸자를 virtual로 선언해야한다. 소멸자 호출 시 동적 바인딩이 발생한다. 

예제 9-6 

소멸자를 가상 함수로 선언하면, 객체를 기본 클래스의 포인터로 소멸하든, 파생클래스의 포인터로 소멸하든 파생 클래스와 기본 클래스의 소멸자를 모두 실행하는 정상적인 소멸의 과정이 진행된다. 따라서 9-6번에서 소멸자에 virtual 키워드를 삭제하고 다시 실행하면 두번째 소멸코드인 delelte bp;는 ~Base()만 실행된다.

가상함수를 가진 기본 클래스의 목적
가상함수는 파생 클래스에서 오버라이딩할 함수를 알려주는 인터페이스의 역할을 한다. 
shape은 가상함수 draw()를 선언하며, 파생 클래스에서 draw()를 오버라이딩하여 자신의 도형을 그리도록 유도한다. Cicle, Rect, Line 등의 파생 클래스는 자신의 모양을 그리기 위해 draw() 함수를 오버라이딩 하고, 파생 클래스들은 가상함수인 draw() 함수를 오버라이딩 함으로써 어떤 경우에도 자신이 만든 draw() 함수가 호출되는 것을 보장 받는다. 

추상 클래스
최소 하나의 순수 가상 함수를 가진 클래스를 뜻한다.

순수 가상 함수(함수의 코드가 없고 선언만 있는 가상 함수)는 파생 클래스에서 재 정의 하여 구현 할 함수를 알려주는 인터페이스의 역할을 한다. 즉, 실행할 코드를 작성할 목적이 아니다. 

특징으로는 온전한 클래스가 아니므로 객체 생성이 불가능하지만 추상 클래스의 포인터는 선언 가능하다. 
목적으로는 추상 클래스의 인스턴스를 생성할 목적이 아니고, 상속에서 기본 클래스의 역할을 하기 위함이다. 

추상 클래스의 상속과 구현
추상 클래스를 단순 상속하면 자동 추상 클래스가 된다. 추상 클래스의 구현은 파생 클래스에 추상 클래스의 순수 가상 함수의 코드를 작성함을 뜻하며, 파생 클래스가 온전한 클래스가 되려면 상속받은 추상 클래스의 모든 순수 가상 함수를 오버라이딩 하여 구현하여야 한다. 

실습문제 10번을 풀면서
왜 프로그래밍을 할때 하나의 코드의 모든 정보를 코딩할수 있음에도 불구하고 나누어서(헤더파일,소스파일,메인파일) 코딩을 할까라는 생각을 하였습니다. 10번문제를 풀면서 생각보다 많은 코드가 나오게 되었고, 길어질수 밖에 없었습니다. 따라서 팀원과 생각 해본 결과 코드를 나누는 이유는 코드의 구조를 조직화하고 코드의 가독성을 높이기 위해서가 아닐까 라는 생각을 하였습니다. 책에서도 관련 내용이 나오기도 했고, 인터넷 검색도 해본 결과. 여러 정보가 나오게 되었습니다. 먼저 코드가 한 파일에 몰려있게되면 코드가 길어지고 복잡해질수 있는데, 여러 파일로 나누게 되면 각 파일의 길이가 줄어들어 가독성이 향상되고, 특정 부분의 수정이나 추가가 간편해져 가독성 및 유지보수성이 향상 된다는 사실입니다. 또한 헤더파일을 만들면 상속의 개념을 배울때 나왔던 코드 재사용 기능을 include를 통해 용이하게 사용할수 있다는 점도 발견했습니다. 또한 아직은 코드가 길고 복잡하지 않아 잘 느끼지 못했지만 추후에 길고 복잡한 코드를 작성하면 컴파일을 할때 시간이 오래 걸린다는 사실도 찾아냈습니다. 이를 해결하기 위해 사용한다고 하였습니다. 따라서 이전까지 파일을 나누는게 크게 와닿지 않았지만 10번 문제를 풀면서 파일을 나누는 방법을 실습해보았고 팀원과 함께 한층 더 성장할수있는 시간이였습니다. 