함수 중복의 약점- 중복함수의  코드 중복 
해결법: 일반화 시키기 
함수나 클래스를 일반화 시키고, 매개 변수 타입을 지정하여 틀에서 찍어 내듯이 함수나 클래스 코드를 생한 하는 기법을 일반화(제네릭)라 한다.

템플릿으로부터의 구체화 
구체화: 템플릿의 제네릭 타입에 구체적인 타입 지정 

제네릭 함수로부터 구체화된 함수 생성 사례
제네릭 함수에서의T가 int로 구체화 되었을때는 c++소스를 생성되었을때 int로 double 경우에도 double로 char일 경우에도 char로 생성된다. 

구체화 오류
구체화 할때 매개변수의 타입은 서로 같아야 한다. 서로 다르게 되면 컴파일 오류가 나오게 된다.

템플릿 장점
함수 코드의 재사용

템플릿 단점
가독성이 떨어질수 있다.
포팅에 취약하다.
컴파일 오류 메세지가 나오지 않아 디버깅에 어려움이 있다.

처음 제네릭 함수를 사용할땐 T 대신 int나 char를 입력해서 확인을 하고 T로 고쳐서 쓰는 방식이 좋다. 

C++ 표준 템플릿 라이브러리, STL
많은 제네릭 클래스와 제네릭 함수를 포함한다.
템플릿 클래스를 컨테이너라고 하며 데이터를 담아두는 자료 구조를 표현한 클래스(리스트, 큐, 스택, 맵, 셋, 벡터)이다. 
iterator는 컨테이너 원소에 대한 포인터로 컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터이다. 

컨테이너 클래스를 사용하기 위한 헤더파일은 vector와 list등이 있으며 #include <000>로 사용가능하다. 
알고리즘 함수를 사용하기 위해서도 #include<algorithm>을 사용하면 된다. 

vector 컨테이너는 가변 길이 배열을 구현한 제네릭 클래스로 원소의 저장, 삭제, 검색 등 다양한 멤버 함수를 지원한다. vector에 저장된 원소는 인덱스로 접근 가능하다. 이때 인덱스는 0부터 시작한다. 

iterator 는 컨테이너의 원소를 가리키는 포인터로 반복자라고도 부른다. 
vector<int>::iterator it;
it = v.begin();
이러한 방법으로 구체적인 컨테이너를 지정하여 반복자 변수를 생성한다. 

map 컨테이너 
('키', '값')의 쌍을 원소로 저장하는 제네릭 컨테이너이다.(동일한 키를 가진 원소가 중복 저장되면 오류 발생)
'키'로 '값'을 검색하며 #include <map>을 필요로 한다.


예제 10-14에서 auto를 이용한 변수 선언에서 auto가 제대로 적용이 잘 되는지 확인해보기 위해 기본 타입 변수에 각각 맞는 타입을 설정하고 돌려본 결과 auto를 사용했을 때와 같게 나왔습니다. 이렇게 auto를 사용하게 되면 코드를 간결하게 만들 수 있고, 타입을 명시적으로 선언하지 않아도 되므로 코드 유지보수가 쉬워집니다. 예제를 풀어본 결과 auto를 사용할 때 주의할 점은, 컴파일러가 변수의 초기값을 통해 타입을 추론하기 때문에 초기값이 없으면 타입을 추론할 수 없습니다. 또한, 가독성을 위해 너무 남용되면 코드가 불명확해질 수 있으므로 적절히 사용하는 것이 좋습니다. auto를 사용하는 것은 코드를 간결하게 만들 수 있는 강력한 도구이지만, 코드를 읽는 사람이 변수의 타입을 추론하기 어려울 때는 명시적인 타입 선언을 해야 할 때도 있다는 것을 알게 되었습니다.

